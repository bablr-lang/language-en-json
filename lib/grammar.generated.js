/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.js#7e62b6b4549e596f0772ea4d6c0a251d0a00f60a
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _initProto;
import { i } from '@bablr/boot';
import { triviaEnhancer } from '@bablr/helpers/trivia';
import * as productions from '@bablr/helpers/productions';
import { buildString } from '@bablr/agast-vm-helpers';
import { Node, CoveredBy, AllowEmpty, InjectFrom, Attributes } from '@bablr/helpers/decorators';
import * as Space from '@bablr/language-blank-space';
export const dependencies = {
  Space
};
export const canonicalURL = 'https://github.com/bablr-lang/language-json';
export const escapables = new Map(Object.entries({
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  '\\': '\\',
  '/': '/'
}));
export const grammar = triviaEnhancer({
  triviaIsAllowed: s => s.span === 'Bare',
  *eatMatchTrivia() {
    if (yield i`match(/[ \n\r\t]/)`) {
      yield i`eat(<#*Space:Space>)`;
    }
  }
}, (_dec = CoveredBy('Element'), _dec2 = CoveredBy('Expression'), _dec3 = CoveredBy('Expression'), _dec4 = CoveredBy('Language'), _dec5 = Attributes(['cooked']), _dec6 = CoveredBy('Expression'), _dec7 = CoveredBy('Expression'), _dec8 = CoveredBy('Expression'), _dec9 = InjectFrom(productions), _dec10 = InjectFrom(productions), class JSONGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_dec, 2, "Expression"], [[_dec2, Node], 2, "Array"], [[_dec3, Node], 2, "Object"], [Node, 2, "Property"], [[_dec4, Node], 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [[_dec5, Node], 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [[_dec6, Node], 2, "Number"], [Node, 2, "Integer"], [Node, 2, "Digit"], [[_dec7, Node], 2, "Boolean"], [[_dec8, Node], 2, "Null"], [[Node, _dec9], 2, "Keyword"], [[Node, _dec10], 2, "Punctuator"]], []).e;
  }
  constructor(...args) {
    _initProto(this);
  }
  *Match({
    value: cases,
    ctx
  }) {
    for (const case_ of ctx.unbox(cases)) {
      const {
        0: matcher,
        1: guard
      } = ctx.unbox(case_);
      if (yield i`match(${guard})`) {
        yield i`eat(${matcher})`;
        break;
      }
    }
  }
  *Expression() {
    yield i`eat(<Match> null [
        (<Array> '[')
        (<Object> '{')
        (<String> '"')
        (<Number span='Number'> /-?\d/)
        (<Null> 'null')
        (<Boolean> /true|false/)
      ])`;
  }
  *Array() {
    yield i`eat(<*Punctuator '[' balanced=']'> 'open')`;
    let first = true;
    while ((first || (yield i`match(',')`)) && (yield i`match(/./)`)) {
      if (!first) {
        yield i`eat(<*Punctuator ','> 'separators[]')`;
      }
      yield i`eat(<Expression> 'elements[]')`;
      first = false;
    }
    if (first) {
      yield i`eat(null 'elements[]')`;
      yield i`eat(null 'separators[]')`;
    }
    yield i`eat(<*Punctuator ']' balancer> 'close')`;
  }
  *Object() {
    yield i`eat(<*Punctuator '{' balanced='}'> 'open')`;
    let first = true;
    while ((first || (yield i`match(',')`)) && !(yield i`match('}')`)) {
      if (!first) {
        yield i`eat(<*Punctuator ','> 'separators[]')`;
      }
      yield i`eat(<Property> 'properties[]')`;
      first = false;
    }
    if (first) {
      yield i`eat(null 'properties[]')`;
      yield i`eat(null 'separators[]')`;
    }
    yield i`eat(<*Punctuator '}' balancer> 'close')`;
  }
  *Property() {
    yield i`eat(<String> 'key')`;
    yield i`eat(<*Punctuator ':'> 'mapOperator')`;
    yield i`eat(<Expression> 'value')`;
  }
  *String({
    ctx
  }) {
    yield i`eat(<*Punctuator '"' balanced='"' balancedSpan='String'> 'open')`;
    yield i`eat(<*StringContent> 'content')`;
    yield i`eat(<*Punctuator '"' balancer> 'close')`;
  }
  *StringContent({
    state: {
      span
    }
  }) {
    let esc, lit;
    do {
      esc = (yield i`match('\\')`) && (yield i`eat(<@EscapeSequence>)`);
      lit = yield i`eatMatch(/[^\r\n\\"]+/)`;
    } while (esc || lit);
  }
  *EscapeSequence({
    state: {
      span
    },
    ctx
  }) {
    if (!span.startsWith('String')) {
      yield i`fail()`;
    }
    yield i`eat(<*Punctuator '\\'> 'escape')`;
    let match, cooked;
    if (match = yield i`match(/[\\/bfnrt"]/)`) {
      const match_ = ctx.sourceTextFor(match);
      yield i`eat(<*Keyword ${buildString(match_)}> 'value')`;
      cooked = escapables.get(match_) || match_;
    } else if (yield i`match('u')`) {
      const codeNode = yield i`eat(<EscapeCode> 'value')`;
      cooked = parseInt(ctx.getProperty(codeNode, 'digits').map(digit => ctx.sourceTextFor(digit)).join(''), 16);
    } else {
      yield i`fail()`;
    }
    yield i`bindAttribute(cooked ${buildString(cooked.toString(10))})`;
  }
  *EscapeCode() {
    yield i`eat(<*Keyword 'u'> 'type')`;
    yield i`eat(<Digits> 'digits[]')`;
    yield i`eatMatch(null 'close')`;
  }
  *Number() {
    yield i`eat(<Integer> 'wholePart' { no00: true matchSign: '-' })`;
    let fs = yield i`eatMatch(<*Punctuator '.'> 'fractionalSeparator')`;
    if (fs) {
      yield i`eat(<Integer> 'fractionalPart')`;
    } else {
      yield i`eat(null 'fractionalPart')`;
    }
    let es = yield i`eatMatch(<*Punctuator /[eE]/> 'exponentSeparator')`;
    if (es) {
      yield i`eat(<Integer> 'exponentPart' { matchSign: /[+-]/ })`;
    } else {
      yield i`eat(null 'exponentPart')`;
    }
  }
  *Integer({
    value: props,
    ctx
  }) {
    const {
      matchSign = null,
      no00 = false
    } = props && ctx.unbox(props) || {};
    if (matchSign) {
      yield i`eatMatch(<*Punctuator ${matchSign}> 'sign')`;
    } else {
      yield i`eat(null 'sign')`;
    }
    let [firstDigit] = ctx.ownTerminalsFor(yield i`eat(<*Digit> 'digits[]')`);
    if (!no00 || firstDigit.value !== '0') {
      while (yield i`eatMatch(<*Digit> 'digits[]')`);
    }
  }
  *Digit() {
    yield i`eat(/\d/)`;
  }
  *Boolean() {
    yield i`eat(<*Keyword /true|false/> 'value')`;
  }
  *Null() {
    yield i`eat(<*Keyword 'null'> 'value')`;
  }
  *Keyword() {}
  *Punctuator() {}
}));