/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#c8de239e6b62ed14750b26b56cf8c5f799bc7520
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _initProto;
import { i } from '@bablr/boot';
import { triviaEnhancer } from '@bablr/helpers/trivia';
import * as productions from '@bablr/helpers/productions';
import { buildString } from '@bablr/agast-vm-helpers';
import { Node, CoveredBy, AllowEmpty, InjectFrom, Attributes } from '@bablr/helpers/decorators';
import * as Space from '@bablr/language-blank-space';
export const dependencies = {
  Space
};
export const canonicalURL = 'https://github.com/bablr-lang/language-json';
export const escapables = new Map(Object.entries({
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  '\\': '\\',
  '/': '/'
}));
export const grammar = triviaEnhancer({
  triviaIsAllowed: s => s.span === 'Bare',
  *eatMatchTrivia() {
    if (yield i`match(/[ \n\r\t]/)`) {
      yield i`eat(<#*Space:Space>)`;
    }
  }
}, (_dec = CoveredBy('Element'), _dec2 = CoveredBy('Expression'), _dec3 = CoveredBy('Expression'), _dec4 = CoveredBy('Language'), _dec5 = Attributes(['cooked']), _dec6 = CoveredBy('Expression'), _dec7 = CoveredBy('Expression'), _dec8 = CoveredBy('Expression'), _dec9 = InjectFrom(productions), _dec10 = InjectFrom(productions), _dec11 = InjectFrom(productions), _dec12 = InjectFrom(productions), class JSONGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_dec, 2, "Expression"], [[_dec2, Node], 2, "Array"], [[_dec3, Node], 2, "Object"], [Node, 2, "Property"], [[_dec4, Node], 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [[_dec5, Node], 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [[_dec6, Node], 2, "Number"], [Node, 2, "Integer"], [Node, 2, "Digit"], [[_dec7, Node], 2, "Boolean"], [[_dec8, Node], 2, "Null"], [[Node, _dec9], 2, "Keyword"], [[Node, _dec10], 2, "Punctuator"], [_dec11, 2, "List"], [_dec12, 2, "Any"]], []).e;
  }
  constructor(...args) {
    _initProto(this);
  }
  *Expression() {
    yield i`eat(<Any> null [
        <Array '['>
        <Object '{'>
        <String '"'>
        <Number /-?\d/ span='Number'>
        <Null 'null'>
        <Boolean /true|false/>
      ])`;
  }
  *Array() {
    yield i`eat(<~*Punctuator '[' balanced=']'> 'openToken')`;
    yield i`eat(<List> 'elements[]' {
        element: <Expression>
        separator: <~*Punctuator ','>
        allowTrailingSeparator: false
      })`;
    yield i`eat(<~*Punctuator ']' balancer> 'closeToken')`;
  }
  *Object() {
    yield i`eat(<~*Punctuator '{' balanced='}'> 'openToken')`;
    yield i`eat(<List> 'properties[]' {
        element: <Property>
        separator: <~*Punctuator ','>
        allowTrailingSeparator: false
      })`;
    yield i`eat(<~*Punctuator '}' balancer> 'closeToken')`;
  }
  *Property() {
    yield i`eat(<String> 'key')`;
    yield i`eat(<~*Punctuator ':'> 'sigilToken')`;
    yield i`eat(<Expression> 'value')`;
  }
  *String() {
    yield i`eat(<~*Punctuator '"' balanced='"' balancedSpan='String'> 'openToken')`;
    yield i`eat(<*StringContent> 'content')`;
    yield i`eat(<~*Punctuator '"' balancer> 'closeToken')`;
  }
  *StringContent() {
    let esc, lit;
    do {
      esc = (yield i`match('\\')`) && (yield i`eat(<@EscapeSequence>)`);
      lit = yield i`eatMatch(/[^\r\n\\"]+/)`;
    } while (esc || lit);
  }
  *EscapeSequence({
    state: {
      span
    },
    ctx
  }) {
    if (!span.startsWith('String')) {
      yield i`fail()`;
    }
    yield i`eat(<~*Punctuator '\\'> 'sigilToken')`;
    let match, cooked;
    if (match = yield i`match(/[\\/bfnrt"]/)`) {
      const match_ = ctx.sourceTextFor(match);
      yield i`eat(<~*Keyword ${buildString(match_)}> 'value')`;
      cooked = escapables.get(match_) || match_;
    } else if (yield i`match('u')`) {
      const codeNode = yield i`eat(<EscapeCode> 'value')`;
      cooked = parseInt(ctx.getProperty(codeNode, 'digits').map(digit => ctx.sourceTextFor(digit)).join(''), 16);
    } else {
      yield i`fail()`;
    }
    yield i`bindAttribute(cooked ${buildString(cooked.toString(10))})`;
  }
  *EscapeCode() {
    yield i`eat(<~*Keyword 'u'> 'typeToken')`;
    yield i`eat(<Digits> 'digits[]')`;
  }
  *Number() {
    yield i`eat(<Integer> 'wholePart' { no00: true matchSign: '-' })`;
    let fs = yield i`eatMatch(<~*Punctuator '.'> 'fractionalSeparatorToken')`;
    if (fs) {
      yield i`eat(<Integer> 'fractionalPart')`;
    } else {
      yield i`eat(null 'fractionalPart')`;
    }
    let es = yield i`eatMatch(<~*Punctuator /[eE]/> 'exponentSeparatorToken')`;
    if (es) {
      yield i`eat(<Integer> 'exponentPart' { matchSign: /[+-]/ })`;
    } else {
      yield i`eat(null 'exponentPart')`;
    }
  }
  *Integer({
    value: props,
    ctx
  }) {
    const {
      matchSign = null,
      no00 = false
    } = props && ctx.unbox(props) || {};
    if (matchSign) {
      yield i`eatMatch(<~*Punctuator ${matchSign}> 'signToken')`;
    } else {
      yield i`eat(null 'signToken')`;
    }
    let [firstDigit] = ctx.ownTerminalsFor(yield i`eat(<*Digit> 'digits[]')`);
    if (!no00 || firstDigit.value !== '0') {
      while (yield i`eatMatch(<*Digit> 'digits[]')`);
    }
  }
  *Digit() {
    yield i`eat(/\d/)`;
  }
  *Boolean() {
    yield i`eat(<~*Keyword /true|false/> 'sigilToken')`;
  }
  *Null() {
    yield i`eat(<~*Keyword 'null'> 'sigilToken')`;
  }
  *Keyword() {}
  *Punctuator() {}
  *List() {}
  *Any() {}
}));