/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#7b49f7b6ef4213f9a53766ecabbf547198b6b021
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateArrayChildren as _interpolateArrayChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto, _ExpressionDecs, _ArrayDecs, _ObjectDecs, _StringDecs, _EscapeSequenceDecs, _NumberDecs, _BooleanDecs, _NullDecs, _KeywordDecs, _PunctuatorDecs, _ListDecs, _AnyDecs;
import { triviaEnhancer } from '@bablr/helpers/trivia';
import * as productions from '@bablr/helpers/productions';
import { buildString, buildBoolean } from '@bablr/agast-vm-helpers';
import { Node, CoveredBy, AllowEmpty, InjectFrom, Attributes } from '@bablr/helpers/decorators';
import * as Space from '@bablr/language-en-blank-space';
export const dependencies = {
  Space
};
export const canonicalURL = 'https://github.com/bablr-lang/language-en-json';
export const escapables = new Map(Object.entries({
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  '\\': '\\',
  '/': '/'
}));
export const grammar = triviaEnhancer({
  triviaIsAllowed: s => s.span === 'Bare',
  *eatMatchTrivia() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit(" ")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\n")], {}, {
                cooked: "\n"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\r")], {}, {
                cooked: "\r"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\t")], {}, {
                cooked: "\t"
              }))], {}, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`triviaToken`, _t.ref`tokenToken`], {
              triviaToken: _t.s_i_node(_l.CSTML, "Punctuator", "#"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            language: _t.s_node(_l.Spamex, "Identifier", "Space"),
            namespaceSeparatorToken: _t.s_i_node(_l.Spamex, "Punctuator", ":"),
            type: _t.s_node(_l.Spamex, "Identifier", "Space"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
}, class JSONGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_ExpressionDecs, 2, "Expression"], [_ArrayDecs, 2, "Array"], [_ObjectDecs, 2, "Object"], [Node, 2, "Property"], [_StringDecs, 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [_EscapeSequenceDecs, 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [_NumberDecs, 2, "Number"], [Node, 2, "Integer"], [Node, 2, "UnsignedInteger"], [_BooleanDecs, 2, "Boolean"], [_NullDecs, 2, "Null"], [_KeywordDecs, 2, "Keyword"], [_PunctuatorDecs, 2, "Punctuator"], [_ListDecs, 2, "List"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_ExpressionDecs = CoveredBy('Element'), _ArrayDecs = [CoveredBy('Expression'), Node], _ObjectDecs = [CoveredBy('Expression'), Node], _StringDecs = [CoveredBy('Language'), Node], _EscapeSequenceDecs = [Attributes(['cooked']), Node], _NumberDecs = [CoveredBy('Expression'), Node], _BooleanDecs = [CoveredBy('Expression'), Node], _NullDecs = [CoveredBy('Expression'), Node], _KeywordDecs = [Node, InjectFrom(productions)], _PunctuatorDecs = [Node, InjectFrom(productions)], _ListDecs = [AllowEmpty, InjectFrom(productions)], _AnyDecs = InjectFrom(productions), Symbol.for('@bablr/fragment'))]() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("root")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Expression() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Any"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Array"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Object"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "String"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Number"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                  element: _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {}),
                  value: _t.s_i_node(_l.Regex, "Keyword", "?")
                }, {
                  min: 0,
                  max: 1,
                  greedy: true
                }), _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                  escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                  value: _t.s_i_node(_l.Regex, "Keyword", "d")
                }, {})]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "span"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Number")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Null"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Boolean"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("l")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
              }, {})],
              separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Array() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
            mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "List"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), _t.node(_l.Instruction, "Object", [_t.ref`openToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "{"),
          properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("element")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Expression"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("separator")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(",")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("allowTrailingSeparator")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "false")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "}")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balancer")
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Object() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
            mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "List"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("properties[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), _t.node(_l.Instruction, "Object", [_t.ref`openToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "{"),
          properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("element")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Property"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("separator")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(",")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("allowTrailingSeparator")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "false")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "}")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balancer")
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Property() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "String"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("key")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit(":")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Expression"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *String() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
            mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
            mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("String")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "StringContent"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("content")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.s_node(_l.Spamex, "Identifier", "balancer")
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *StringContent() {
    let esc, lit;
    do {
      esc = (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "match"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`escapeToken`], {
              escapeToken: _t.s_i_node(_l.CSTML, "Punctuator", "@")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "EscapeSequence"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {}));
      lit = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  negateToken: _t.s_i_node(_l.Regex, "Keyword", "^"),
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\r")], {}, {
                    cooked: "\r"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\n")], {}, {
                    cooked: "\n"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: true
                }),
                value: _t.s_i_node(_l.Regex, "Keyword", "+")
              }, {
                min: 1,
                max: Infinity,
                greedy: true
              })]
            }, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } while (esc || lit);
  }
  *EscapeSequence({
    state: {
      span
    },
    ctx
  }) {
    if (!span.startsWith('String')) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
            key: _t.s_node(_l.Spamex, "Identifier", "openSpan"),
            mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let match, cooked;
    if (match = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("/")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("b")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const match_ = ctx.sourceTextFor(match);
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: buildString(match_),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = escapables.get(match_) || match_;
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("u")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const codeNode = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "EscapeCode"),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = parseInt(codeNode.properties.digits.map(digit => ctx.sourceTextFor(digit)).join(''), 16);
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildString(cooked.toString(10)), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.s_node(_l.Instruction, "Identifier", "cooked"), ..._interpolateArray(buildString(cooked.toString(10)))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EscapeCode() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("u")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("typeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("digits[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Number() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Integer"),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("wholePart")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), _t.node(_l.Instruction, "Object", [_t.ref`openToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "{"),
          properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("noDoubleZero")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "true")
            }, {})
          }, {}), _t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("matchSign")], {}, {}),
            mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "}")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let fs = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("fractionalSeparatorToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (fs) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Integer"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("fractionalPart")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("fractionalPart")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    let es = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("e")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("E")], {}, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: false
              })]
            }, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("exponentSeparatorToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (es) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Integer"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("exponentPart")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}), _t.node(_l.Instruction, "Object", [_t.ref`openToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "{"),
            properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
              key: _t.node(_l.Instruction, "LiteralTag", [_t.lit("matchSign")], {}, {}),
              mapToken: _t.s_i_node(_l.Instruction, "Punctuator", ":"),
              value: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {})
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "}")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("exponentPart")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Integer({
    value: props,
    ctx
  }) {
    const {
      matchSign = null,
      noDoubleZero = false
    } = props && ctx.unbox(props) || {};
    if (matchSign) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: matchSign,
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("signToken")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("signToken")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
            key: _t.s_node(_l.Spamex, "Identifier", "noDoubleZero"),
            mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: buildBoolean(noDoubleZero)
          }, {})],
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *UnsignedInteger({
    value: props,
    ctx
  }) {
    const {
      noDoubleZero = false
    } = props && ctx.unbox(props) || {};
    let [firstDigit] = ctx.allTagsFor(yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
              escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
              value: _t.s_i_node(_l.Regex, "Keyword", "d")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
    if (!noDoubleZero || firstDigit.value !== '0') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                  escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                  value: _t.s_i_node(_l.Regex, "Keyword", "d")
                }, {}),
                value: _t.s_i_node(_l.Regex, "Keyword", "+")
              }, {
                min: 1,
                max: Infinity,
                greedy: true
              })]
            }, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Boolean() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
            }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("l")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
            }, {})],
            separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Null() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
            intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
            tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
          }, {}),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Keyword() {}
  *Punctuator() {}
  *List() {}
  *Any() {}
});